# file_streamer

Написанный здесь код - переделывание тестового задания, которое было сделано 9 месяцев назад.

С предыдущей версией можно ознакомиться [в этом репозитории](https://github.com/dudelka/udp_server/).

## Описание проекта

Этот проект реализует сервис передачи файлов, состоящий из двух компонент: __UDP-сервера и клиента__.

Сервер получает данные, записывает их в память и вычисляет от полученных данных __crc32__ контрольную сумму.

Клиент отправляет данные серверу по протоколу __UDP__; сервер получает данные, вычисляет от них контрольную сумму и возвращает ее клиенту.

Для передачи файла, клиент разбивает его на пакеты определенного формата (формат пакетов определен в `packet.hpp`).

После отправки всего файла, клиент получает от сервера пакет с контрольной суммой и сравнивает полученное значение с вычисленным самостоятельно.

## Описание протокола передачи данных

Есть два типа пакетов: _**управляющие**_ и _**пакеты с данными**_

* **_управляющие пакеты_**
  * **_CONNECT_** - отправляется клиентом на сервер для установления соединения.
  * **_CONNECT_RESPONSE_** - отправляется сервером на клиент при получении пакета **_CONNECT_**.
  * **_SHUTDOWN_** - отправляется клиентом на сервер для закрытия соединения.
  * **_SHUTDOWN_RESPONSE_** - отправляется сервером на клиент при получении пакета **_SHUTDOWN_**.
  * **_ACK_** - подтверждающий пакет, отправляется клиенту от сервера при получении пакета **_PUT_**.

* _**пакеты с данными**_
  * **_PUT_** - пакет с полезной нагрузкой от клиента серверу.

Вне зависимости от того, какая программа будет запущена первой (_клиент или сервер_), обмен данными не будет начат, пока не установится соединение между клиентом и сервером.

В первую очередь, клиент отправляет пакет типа **_CONNECT_** один раз в установленный таймаут (задается в опциях командной строки), пока не получит от сервера пакет типа **_CONNECT_RESPONSE_**.

Затем на клиенте начинают формироваться пакеты типа **_PUT_**. Поле `Packet::seq_number_` выставляется равным номеру текущего отправляемого пакета (нумерация идет с нуля), а `Packet::seq_total_` выставляется равным необходимому числу пакетов, чтобы полностью отправить файл.

Получив пакет с данными, сервер сразу высылает подтверждение => формируется пакет типа **_ACK_**. `Packet::seq_number_` выставляется равным номеру полученного пакета, `Packet::seq_total_` - общему числу полученных пакетов. Если на какой-то отправленный пакет клиент не получил подтверждение за определенный таймаут, то он отправляется снова.

На сервере файл считается полностью полученным, если его `Packet::seq_total_` равен количеству полученных пакетов с данными. Если файл завершен, то тогда сервер отправляет последний **_ACK_** пакет с самостоятельно вычисленной контрольной суммой.

Стоит отметить, что сервер может получать пакеты, которые соответствуют разным файлам. Вне зависимости от того, в каком порядке будут приходить данные, сервер самостоятельно их переупорядочит.

После того  как клиент отправит все файлы, формируется управляющий пакет типа **_SHUTDOWN_**, который будет отправляться на сервер раз в таймаут до тех пор пока не придет управляющий пакет **_SHUTDOWN_RESPONSE_** от сервера. После этого клиент сверяет полученные контрольные суммы и завершает свою работу; сервер же будет работать еще какое-то время, которое задается с помощью опции **_--timeout_**. Это нужно для того, чтобы в случае если **_SHUTDOWN_RESPONSE_** не дойдет до клиента, он смог снова отправить серверу команду на отключение.

## Архитектура проекта

#### Клиент

```
File_1 -> Divide into chunks -> PacketManager_1 -\
                                                  \
  ...                                               --> Sender -> Send packet to server -> Put packet to sender's resend buffer
                                                  /           \
File_n -> Divide into chunks -> PacketManager_n -/             \- Resend not acknowledged packets to server -> Put packet to sender's resend buffer
```

```
                                /-> PacketManager_1 -> PacketType::ACK -> Notify sender to pop packet from resend buffer
                              /
Receiver -> Received packet -           ...
                              \
                               \-> Packet manager_n -> PacketType::ACK -> Notify sender to pop packet from resend buffer
```

Функция __main__ клиента описана в файле `src/client.cpp`. Сначала считываются файлы на отправку, для этого используется функция `GenerateFiles`, которая возвращает `std::vector<File>`. Само описание класса `File` находится в `src/file.hpp`.

После считывания файлов создаются классы `Sender` и `Receiver` и устанавливается соединение. `Sender` отправляет пакеты **_CONNECT_** один раз в таймаут, который задается через опцию **__--timeout__** (по умолчанию 15 микросекунд). 

Затем, получив ответ от сервера, в __main__ создается поток: в нем запускается метод `Sender::Run`, в основном же - `Receiver::Run`.

В методе `Sender::run`так же запускается новый поток, в котором работает метод `Sender::ResendPackets`. Оба этих потока блокируются до наступления определенного условия: **run_thread** ждет, пока в буфере на отправку появится хотя бы один пакет; для метода `Sender::ResendPackets` выделен свой буфер и поэтому **resend_thread** так же ожидает появления пакета в своем буфере. После выполнения условия, пакеты переходят в сокет для дальнейшей отправки. Если за установленный таймаут пакет не был подтвержден, то он будет переотправлен в **resend_thread**.

В `Receiver::Run` для каждого класса `PacketManager` создается отдельный поток, в котором вызывается `PacketManager::Run`. В этом потоке `PacketManager` просто формирует пакеты на отправку из разбитого на чанки файла и передает их на отправку классу `Sender`. Помимо этого, после создания всех потоков, сокет ресивера начинает принимать приходящие пакеты подтверждения от сервера, которые затем через `PacketManager::AckPacket` убираются из буфера для переотправки сендера.

Как только все файлы были отправлены, клиент начинает отправлять пакеты типа **_SHUTDOWN_** до тех пор, пока не получит пакет от сервера с типом **_SHUTDOWN_RESPONSE_**
После этого клиент проверяет отправленные и полученные контрольные суммы.

#### Сервер

```
                               /-> PacketManager_1 -\
                              /                      \
Receiver -> PacketType::PUT -                         --> PacketType::ACK -> Sender -> Send acknowledgement to client
                              \                      /
                               \-> PacketManager_n -/
```

Сервер устроен проще, чем клиент. Функция __main__ сервера описана в файле `src/server.cpp`. Здесь так же создаются `Sender` и `Receiver` и сразу же вызывается метод `Receiver::run`. Но стоит отметить, что у клиента и сервера эти методы сильно отличаются. Потому что в данном случае ресивер просто мониторит приходящие пакеты, от которых зависит дальнейшее поведение программы. Возможны три случая:

  1. `PacketType::CONNECT`
  2. `PacketType::PUT`
  3. `PacketType::SHUTDOWN`

В первом и третьем случае будут сгенерированы пакеты типа **__CONNECT_RESPONSE__** и **_SHUTDOWN_RESPONSE_** соответственно, которые потом будут переданы сендеру для дальнейшей отправки.

Во втором же случае сначала будет распознан _id_ пришедшего пакета, и если до этого такой _id_ не был замечен на сервере, то для него будет сконструирован свой `PacketManager`, куда этот пакет и перейдет. Оттуда уже для данного пакета будет сформировано подтверждение и отправлено клиенту, также из этого пакета сервер будет собирать файл.

Еще нужно помнить, что в самом начале метода `Receiver::run` создается таймер, который отключит сервер, если за определенный таймаут (опция **_--timeout_**, значение по умолчанию - 30 секунд) не придет ни одного сообщения от клиента.

## Запуск клиента и сервера

Для запуска программ будет достаточно этих команд. Для более подробного описания опций введите `--help` в аргументах командной строки.

#### Клиент 

```
./client --file --send_address <ip>:<port> --receive_address <ip>:<port>
```

#### Сервер

```
./server --send_address <ip>:<port> --receive_address <ip>:<port>
```

## Сборка и тестирование

Для сборки проекта введите команду

```
make
```

Для запуска тестов нужно вызвать команду

```
make run
```

Также можно запустить тесты вручную

```
/tests/run_test.py
```
