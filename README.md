# file_streamer

Написанный здесь код - переделывание тестового задания, которое было сделано 9 месяцев назад.

С предыдущей версией можно ознакомиться [в этом репозитории](https://github.com/dudelka/udp_server/).

## Описание проекта

Этот проект реализует сервис передачи файлов, состоящий из двух компонент: __UDP-сервера и клиента__.

Сервер получает данные, записывает их в память и вычисляет от полученных данных __crc32__ контрольную сумму.

Клиент отправляет данные серверу по протоколу __UDP__; сервер получает данные, вычисляет от них контрольную сумму и возвращает ее клиенту.

Для передачи файла, клиент разбивает его на пакеты определенного формата (формат пакетов определен в `packet.hpp`).

После отправки всего файла, клиент получает от сервера пакет с контрольной суммой и сравнивает полученное значение с вычисленным самостоятельно.

## Описание протокола передачи данных

Есть два типа пакетов: _**управляющие**_ и _**пакеты с данными**_

* **_управляющие пакеты_**
  1. _CONNECT_ - отправляется клиентом на сервер для установления соединения.
  2. _CONNECT_RESPONSE_ - отправляется сервером на клиент при получении пакета _CONNECT_.
  3. _SHUTDOWN_ - отправляется клиентом на сервер для закрытия соединения.
  4. _SHUTDOWN_RESPONSE_ - отправляется сервером на клиент при получении пакета _SHUTDOWN_.
  5. _ACK_ - подтверждающий пакет, отправляется клиенту от сервера при получении пакета _PUT_.

* _**пакеты с данными**_
  1. _PUT_ - пакет с полезной нагрузкой от клиента серверу.

Вне зависимости от того, какая программа будет запущена первой (_клиент или сервер_), обмен данными не будет начат, пока не установится соединение между клиентом и сервером.

В первую очередь, клиент отправляет пакет типа _CONNECT_ один раз в установленный таймаут (задается в опциях командной строки), пока не получит от сервера пакет типа _CONNECT_RESPONSE_.

Затем на клиенте начинают формироваться пакеты типа _PUT_. Поле `Packet::seq_number_` выставляется равным номеру текущего отправляемого пакета (нумерация идет с нуля), а `Packet::seq_total_` выставляется равным необходимому числу пакетов, чтобы полностью отправить файл.

Получив пакет с данными, сервер сразу высылает подтверждение => формируется пакет типа _ACK_. `Packet::seq_number_` выставляется равным номеру полученного пакета, `Packet::seq_total_` - общему числу полученных пакетов. Если на какой-то отправленный пакет клиент не получил подтверждение за определенный таймаут, то он отправляется снова.

На сервере файл считается полностью полученным, если его `Packet::seq_total_` равен количеству полученных пакетов с данными. Если файл завершен, то тогда сервер отправляет последний ACK пакет с самостоятельно вычисленной контрольной суммой.

Стоит отметить, что сервер может получать пакеты, которые соответствуют разным файлам. Вне зависимости от того, в каком порядке будут приходить данные, сервер самостоятельно их переупорядочит.

После того  как клиент отправит все файлы, формируется управляющий пакет типа _SHUTDOWN_, который будет отправляться на сервер раз в таймаут до тех пор пока не придет управляющий пакет _SHUTDOWN_RESPONSE_ от сервера. После этого клиент сверяет полученные контрольные суммы и завершает свою работу; сервер же будет работать еще какое-то время, которое задается с помощью опции _--timeout_. Это нужно для того, чтобы в случае если _SHUTDOWN_RESPONSE_ не дойдет до клиента, он смог снова отправить серверу команду на отключение.

## Архитектура проекта



## Сборка и тестирование

Для сборки проекта введите команду

```
make
```

Для запуска тестов нужно вызвать команду

```
make run
```

Также можно запустить тесты вручную

```
/tests/run_test.py
```

## Запуск клиента и сервера
